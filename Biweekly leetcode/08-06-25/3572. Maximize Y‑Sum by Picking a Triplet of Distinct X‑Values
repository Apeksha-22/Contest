# Intuition
<!-- Describe your first thoughts on how to solve this problem. -->
Since we are only allowed to choose elements where all x[i], x[j], and x[k] are distinct, we don't care about the full array â€” just the maximum y values corresponding to distinct x values.

So the idea is:

    For each unique x[i], keep only the maximum y[i].

Then pick the top 3 largest y-values among them to get the answer.

# Approach
<!-- Describe your approach to solving the problem. -->
1. Map Creation:
    Create a map (unordered_map<int, int>) to store each distinct x[i] and its corresponding maximum y[i].

    Traverse the input arrays and populate the map:

        mp[x[i]] = max(mp[x[i]], y[i]);
2. Sort the values:

    Extract the values (i.e., all max y[i] values) from the map.

    Sort them in descending order.

3. Pick Top 3:

    If there are at least 3 distinct x[i] values, pick the top 3 largest y[i] and return their sum. 

        else, return -1.

# Complexity
- Time complexity:
<!-- Add your time complexity here, e.g. $$O(n)$$ -->
    Total: O(n + m log m)

- Space complexity:
<!-- Add your space complexity here, e.g. $$O(n)$$ -->
    Total: O(m)

# Code
```cpp []
class Solution {
public:
    int maxSumDistinctTriplet(vector<int>& x, vector<int>& y) {
    unordered_map<int, int> mp;

    int n = x.size();
    for (int i = 0; i < n; i++) {
        mp[x[i]] = max(mp[x[i]], y[i]);
    }
    vector<int> maxYs;
    for (auto& p : mp) {
        maxYs.push_back(p.second);
    }
    if (maxYs.size() < 3) return -1;
    sort(maxYs.begin(), maxYs.end(), greater<int>());

    return maxYs[0] + maxYs[1] + maxYs[2];
    }
};

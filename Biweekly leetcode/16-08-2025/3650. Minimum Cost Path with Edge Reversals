class Solution {
public:
    int minCost(int n, vector<vector<int>>& edges) {
        vector<vector<int>> temp = edges;
        vector<vector<pair<int,int>>> adj(n);
        for (auto &i : temp) {
            int x = i[0], y = i[1], z = i[2];            
            adj[x].push_back({y, z});
            adj[y].push_back({x, 2 * z});
        }

        const long long INF = (long long) 1e18;
        vector<long long> dist(n, INF);
        typedef pair<long long,int> P;
		priority_queue<P, vector<P>, greater<P>> pq;


        dist[0] = 0;
        pq.push({0, 0});

        while (!pq.empty()) {
            auto [i, j] = pq.top(); pq.pop();
            if (i != dist[j]) continue;
            if (j == n - 1) return (int)i;
            for (auto &p : adj[j]) {
                int v = p.first;
                long long k = p.second;
                if (dist[v] > i + k) {
                    dist[v] = i + k;
                    pq.push({dist[v], v});
                }
            }
        }

        return dist[n-1] == INF ? -1 : (int)dist[n-1];
    }
};
